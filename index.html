<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>操作系统期末复习闯关 (100题无删减完整版)</title>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Framer Motion (for animations) -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <style>
        body {
            background-color: #f3f4f6;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll, handle in app */
        }
        
        /* Custom scrollbar for sidebar */
        .sidebar-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-scroll::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar-scroll::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 20px;
        }

        /* Custom scrollbar for main content */
        .main-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .main-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .main-scroll::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 20px;
            border: 2px solid #f1f5f9;
        }
        
        /* Table Styles */
        .os-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .os-table th, .os-table td {
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            text-align: center;
            white-space: nowrap;
        }
        .os-table th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #475569;
        }
        .os-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        /* Mobile optimization for tables */
        @media (max-width: 640px) {
            .os-table {
                font-size: 0.8rem;
            }
            .os-table th, .os-table td {
                padding: 6px 8px;
            }
        }

        /* Code Block Styles */
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.85rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { motion, AnimatePresence } = window.Motion;

        // Full Question Database (100 Questions) - REVISED AND COMPLETED
        const questionsData = [
            // --- Part 1: Process Management (Questions 1-25) ---
            {
                id: 1,
                question: "下列关于批处理系统的叙述中，正确的是（ ）。\n①批处理系统允许多个用户与计算机直接交互\n②批处理系统分为单道批处理系统和多道批处理系统\n③中断技术使得多道批处理系统的I/O设备可与CPU并行工作",
                options: ["A. 仅②、③", "B. 仅②", "C. 仅①、②", "D. 仅①、③"],
                answer: "A",
                explanation: "批处理系统的显著特点是用户无法与计算机直接交互（脱机），因此①错误；批处理确实分为单道和多道，②正确；多道批处理系统中，利用中断技术和通道技术实现了CPU与I/O设备的并行工作，③正确。故选A。"
            },
            {
                id: 2,
                question: "下列关于 CPU 模式的叙述中，正确的是（ ）。",
                options: ["A. CPU处于用户态时只能执行特权指令", "B. CPU处于内核态时只能执行特权指令", "C. CPU处于用户态时只能执行非特权指令", "D. CPU处于内核态时只能执行非特权指令"],
                answer: "C",
                explanation: "CPU处于用户态时，为了安全，只能执行非特权指令；CPU处于内核态时，权限最高，既可以执行特权指令也可以执行非特权指令。故选C。"
            },
            {
                id: 3,
                question: "本地用户通过键盘登录系统时，首先获得键盘输入信息的程序是（ ）。",
                options: ["A. 命令解释程序", "B. 中断处理程序", "C. 系统调用服务程序", "D. 用户登录程序"],
                answer: "B",
                explanation: "用户按下键盘时，会产生硬件中断，CPU暂停当前工作转去执行相应的中断处理程序来读取键盘输入的信息。这是最底层的响应，之后才会传递给登录程序等上层软件。故选B。"
            },
            {
                id: 4,
                question: "下列关于系统调用的叙述中，正确的是（ ）。\n①在执行系统调用服务程序的过程中，CPU处于内核态\n②操作系统通过提供系统调用避免用户程序直接访问外设\n③不同的操作系统为应用程序提供了统一的系统调用接口\n④系统调用是操作系统内核为应用程序提供服务的接口",
                options: ["A. 仅①、④", "B. 仅②、③", "C. 仅①、②、④", "D. 仅①、③、④"],
                answer: "C",
                explanation: "①正确，执行系统调用代码属于内核代码，处于内核态；②正确，系统调用是用户程序访问硬件的唯一合法接口；③错误，不同操作系统（如Windows和Linux）的系统调用接口是不兼容的；④正确。故选C。"
            },
            {
                id: 5,
                question: "某单CPU系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输入、计算和输出的时间均分别为2ms、3ms和4ms，且都按输入、计算和输出的顺序执行，则执行完3个作业需要的时间最少是（ ）。",
                options: ["A. 15ms", "B. 17ms", "C. 22ms", "D. 27ms"],
                answer: "B",
                explanation: "利用流水线技术分析：\n作业1: I(0-2) C(2-5) O(5-9)\n作业2: I(2-4) C(5-8) O(9-13)\n作业3: I(4-6) C(8-11) O(13-17)\n最后一个作业完成时间是17ms。故选B。"
            },
            {
                id: 6,
                question: "内部异常(内中断)可分为故障(fault)、陷阱(trap)和终止(abort)三类。下列有关内部异常的叙述中，错误的是（ ）。",
                options: ["A. 内部异常的产生与当前执行指令相关", "B. 内部异常的检测由CPU内部逻辑实现", "C. 内部异常的响应发生在指令执行过程中", "D. 内部异常处理后返回到发生异常的指令继续执行"],
                answer: "D",
                explanation: "不是所有内部异常处理后都返回原指令。例如“终止(abort)”通常因严重的硬件故障产生，处理后会终止进程，不会返回；“陷阱(trap)”通常返回下一条指令。D的说法太绝对，错误。故选D。"
            },
            {
                id: 7,
                question: "下列选项中，会导致用户进程从用户态切换到内核态的操作是（ ）。\n①整数除以零 ②sin()函数调用 ③read系统调用",
                options: ["A. 仅①、②", "B. 仅①、③", "C. 仅②、③", "D. ①、②和③"],
                answer: "B",
                explanation: "①整数除零会引发“异常”，导致切换到内核态处理；③read是系统调用，本质是“陷入”指令，会切换到内核态；②sin()是数学库函数，通常在用户态执行计算，不涉及内核态切换。故选B。"
            },
            {
                id: 8,
                question: "从下面关于并发性的论述中选出一条正确的论述（ ）。",
                options: ["A. 并发性是指若干事件在同一时刻发生", "B. 并行性是指若干事件在不同时刻发生", "C. 并发性是指若干事件在同一时间间隔内发生", "D. 并发性是指若干事件在不同时间间隔内发生"],
                answer: "C",
                explanation: "并发(Concurrency)是指宏观上同时发生（同一时间间隔内），微观上交替执行；并行(Parallelism)是指同一时刻真正同时进行。故选C。"
            },
            {
                id: 9,
                question: "执行系统调用的过程包括如下主要操作：\n①返回用户态 ②执行陷入(trap)指令 ③传递系统调用参数 ④执行相应的服务程序\n正确的执行顺序是（ ）。",
                options: ["A. ②→③→①→④", "B. ②→④→③→①", "C. ③→②→④→①", "D. ③→④→②→①"],
                answer: "C",
                explanation: "正确步骤：先传递参数(③) -> 执行Trap指令触发中断(②) -> 内核态执行服务程序(④) -> 返回用户态(①)。故选C。"
            },
            {
                id: 10,
                question: "分时操作系统通常采用（ ）策略为用户服务。",
                options: ["A. 可靠性和安全性", "B. 时间片轮转", "C. 时间片加权分配", "D. 短作业优先"],
                answer: "B",
                explanation: "分时系统的目标是交互性和响应时间，让每个用户感觉独占CPU，因此普遍采用时间片轮转调度算法。故选B。"
            },
            {
                id: 11,
                question: "下列选项中，会导致进程从执行态变为就绪态的事件是（ ）。",
                options: ["A. 执行P(wait)操作", "B. 申请内存失败", "C. 启动I/O设备", "D. 被高优先级进程抢占"],
                answer: "D",
                explanation: "A、B、C都会导致进程因为缺少资源或等待事件而进入“阻塞态”。D被抢占时，进程依然具备运行条件，只是失去了CPU，因此回到“就绪态”。故选D。"
            },
            {
                id: 12,
                question: "下列由当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态的是（ ）。",
                options: ["A. 键盘输入", "B. 缺页异常", "C. 主动出让 CPU", "D. 执行信号量的wait()操作"],
                answer: "C",
                explanation: "A、B、D都会导致线程需要等待（I/O、内存页面、信号量），从而进入阻塞态。C主动出让（如yield）是自愿放弃CPU，回到就绪队列等待下一次调度。故选C。"
            },
            {
                id: 13,
                question: "进程的基本状态（ ）可以由其他两种基本状态转变而来。",
                options: ["A. 就绪状态", "B. 执行状态", "C. 阻塞状态", "D. 新建状态"],
                answer: "A",
                explanation: "就绪状态可以来源自：1. 新建状态（创建完成）；2. 执行状态（时间片完）；3. 阻塞状态（I/O完成）。执行只能来自就绪，阻塞只能来自执行。故选A。"
            },
            {
                id: 14,
                question: "当一个进程（ ），就要退出等待队列而进入就绪队列。",
                options: ["A. 启动了外设", "B. 用完了规定的时间片", "C. 获得了所等待的资源", "D. 能得到所等待的处理器"],
                answer: "C",
                explanation: "“等待队列”即阻塞队列。当进程等待的事件发生或获得了所需的资源（非CPU），它就从阻塞态变为就绪态，进入就绪队列。故选C。"
            },
            {
                id: 15,
                question: "下列事件或操作中，可能导致进程 P 由执行态变为阻塞态的是（ ）。\n①进程 P 读文件 ②进程 P 的时间片用完 ③进程 P 申请外设 ④进程 P 执行信号量的 wait()操作",
                options: ["A. 仅①、④", "B. 仅②、③", "C. 仅③、④", "D. 仅①、③、④"],
                answer: "D",
                explanation: "①读文件需等待I/O，阻塞；②时间片用完变就绪；③申请外设若被占用则阻塞；④wait操作若信号量不足则阻塞。故选D。"
            },
            {
                id: 16,
                question: "下列选项中，导致创建新进程的操作是（ ）。\n①用户登录成功 ②设备分配 ③启动程序执行",
                options: ["A. 仅①和②", "B. 仅②和③", "C. 仅①和③", "D. ①、②和③"],
                answer: "C",
                explanation: "①用户登录通常会创建一个Shell进程或桌面进程；③启动程序执行显然需要创建新进程；②设备分配只是将设备分配给已有进程，不创建新进程。故选C。"
            },
            {
                id: 17,
                question: "下列操作中，操作系统在创建新进程时，必须完成的是（ ）。\n①申请空白的进程控制块 ②初始化进程控制块 ③设置进程状态为执行态",
                options: ["A. 仅①", "B. 仅①、②", "C. 仅①、③", "D. 仅②、③"],
                answer: "B",
                explanation: "进程创建原语的主要工作：申请PCB(①)、分配资源、初始化PCB(②)、插入就绪队列。创建后的初始状态通常是就绪态，而不是直接运行(③)。故选B。"
            },
            {
                id: 18,
                question: "下列关于管道( Pipe )通信的叙述中，正确的是（ ）。",
                options: ["A. 一个管道可实现双向数据传输", "B. 管道的容量仅受磁盘容量大小限制", "C. 进程对管道进行读操作和写操作都可能被阻塞", "D. 一个管道只能有一个读进程或一个写进程对其操作"],
                answer: "C",
                explanation: "普通管道通常是半双工（单向）的；管道本质是内存缓冲区（通常一页大小），容量有限；管道读空或写满时，相关进程会被阻塞；管道允许多个进程读写（如父子进程）。故选C。"
            },
            {
                id: 19,
                question: "下列关于线程的叙述中，错误的（ ）。",
                options: ["A. 内核级线程的调度由操作系统完成", "B. 操作系统为每个用户级线程建立一个线程控制块", "C. 用户级线程间的切换比内核级线程间的切换效率高", "D. 用户级线程可以在不支持内核级线程的操作系统上实现"],
                answer: "B",
                explanation: "操作系统内核感知不到用户级线程的存在，因此不会为它们建立TCB。用户级线程的TCB由用户空间的线程库管理。故选B。"
            },
            {
                id: 20,
                question: "下列关于进程和线程的叙述中，正确的是（ ）。",
                options: ["A. 不管系统是否支持线程，进程都是资源分配的基本单位", "B. 线程是资源分配的基本单位，进程是调度的基本单位", "C. 系统级线程和用户级线程的切换都需要内核的支持", "D. 同一进程中的各个线程拥有各自不同的地址空间"],
                answer: "A",
                explanation: "A正确，进程始终是资源分配的单位。B错，线程是调度单位。C错，用户级线程切换不需内核。D错，同一进程的线程共享地址空间。故选A。"
            },
            {
                id: 21,
                question: "在支持多线程的系统中，进程P创建的若干线程不能共享的是（ ）。",
                options: ["A. 进程P的代码段", "B. 进程P中打开的文件", "C. 进程P的全局变量", "D. 进程P中某线程的栈指针"],
                answer: "D",
                explanation: "线程共享代码、数据（全局变量）、文件等，但为了独立执行，每个线程必须有自己独立的栈（栈指针）和程序计数器。故选D。"
            },
            {
                id: 22,
                question: "使用TSL(Test and Set Lock)指令实现进程互斥的伪代码如下所示。下列与该实现机制相关的叙述中，正确的是（ ）。",
                code: "do{\n ...\n while( TSL( &lock) );\n critical section;\n lock= FALSE;\n ...\n} while( TRUE);",
                options: ["A. 退出临界区的进程负责唤醒阻塞态进程", "B. 等待进入临界区的进程不会主动放弃CPU", "C. 上述伪代码满足“让权等待”的同步准则", "D. while( TSL( &lock) )语句应在关中断状态下执行"],
                answer: "B",
                explanation: "TSL实现的是自旋锁（Busy Waiting），进程在while循环中不断测试，不会主动放弃CPU进入阻塞态，因此不满足“让权等待”。退出时只需置lock为FALSE，无需唤醒（因为等待者在忙等）。故选B。"
            },
            {
                id: 23,
                question: "下列准则中，实现临界区互斥机制必须遵循的是（ ）。\n①两个进程不能同时进入临界区\n②允许进程访问空闲的临界资源\n③进程等待进入临界区的时间是有限的\n④不能进入临界区的执行态进程立即放弃CPU",
                options: ["A. 仅①、④", "B. 仅②、③", "C. 仅①、②、③", "D. 仅①、③、④"],
                answer: "C",
                explanation: "互斥机制必须满足：空闲让进(②)、忙则等待(①)、有限等待(③)。④“让权等待”是理想原则，但不是必须遵循的（例如自旋锁就不遵循）。故选C。"
            },
            {
                id: 24,
                question: "有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示。两个操作完成后，x的值（ ）。",
                tableData: [
                    ["//加1操作", "", "//减1操作"],
                    ["load R1, x", "//取x到寄存器R1中", "load R2, x"],
                    ["inc R1", "", "dec R2"],
                    ["store x,R1", "//将R1的内容存入x", "store x, R2"]
                ],
                options: ["A. 可能为-1或3", "B. 只能为1", "C. 可能为0、1或2", "D. 可能为-1、0、1或2"],
                answer: "C",
                explanation: "这是典型的竞态条件。初始x=1。\n1. 串行：1+1-1=1。\n2. P1读1, P2读1, P1存2, P2存0 -> 结果0。\n3. P1读1, P2读1, P2存0, P1存2 -> 结果2。\n故结果可能为0, 1, 2。选C。"
            },
            {
                id: 25,
                question: "设与某资源关联的信号量初值为3，当前值为1。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（ ）。",
                options: ["A. 0、1", "B. 1、0", "C. 1、2", "D. 2、0"],
                answer: "B",
                explanation: "信号量值 S > 0 时，S 代表可用资源数，等待进程数为0。当前 S=1，表示有1个资源可用，无进程等待。故 M=1, N=0。选B。"
            },
            
            // --- Part 2: Deadlock & Scheduling (Questions 26-50) ---
            {
                id: 26,
                question: "死锁的预防是根据（ ）而采取措施实现的。",
                options: ["A. 配置足够的系统资源", "B. 使进程的推进顺序合理", "C. 破坏死锁的四个必要条件之一", "D. 防止系统进入不安全状态"],
                answer: "C",
                explanation: "死锁预防（Prevention）的策略是通过破坏产生死锁的四个必要条件（互斥、请求与保持、不可剥夺、循环等待）中的一个或多个来确保死锁不发生。D是死锁避免（Avoidance）。故选C。"
            },
            {
                id: 27,
                question: "死锁与安全状态的关系是（ ）。",
                options: ["A. 死锁状态有可能是安全状态", "B. 安全状态有可能成为死锁状态", "C. 不安全状态就是死锁状态", "D. 死锁状态一定是不安全状态"],
                answer: "D",
                explanation: "安全状态一定不会死锁；死锁状态一定是不安全状态；但不安全状态不一定会死锁（只是有死锁的风险）。故选D。"
            },
            {
                id: 28,
                question: "假设系统中有4个同类资源，进程P1、P2和P3需要的资源数分别为4、3和1，P1、P2和P3已申请到的资源数分别为2、1和0，则执行安全性检测算法的结果是( )。",
                options: ["A. 不存在安全序列，系统处于不安全状态", "B. 存在多个安全序列，系统处于安全状态", "C. 存在唯一安全序列P3、P1、P2，系统处于安全状态", "D. 存在唯一安全序列P3、P2、P1，系统处于安全状态"],
                answer: "A",
                explanation: "总资源=4。已分配：2+1+0=3。剩余可用=1。\n需求(Need)：P1(4-2=2), P2(3-1=2), P3(1-0=1)。\n可用资源1只能满足P3。P3执行完释放0（注意P3原本占0），可用仍为1。\n此时1无法满足P1(需2)或P2(需2)。无法继续，系统处于不安全状态。故选A。"
            },
            {
                id: 29,
                question: "下列关于银行家算法的叙述中，正确的是( )。",
                options: ["A. 银行家算法可以预防死锁", "B. 当系统处于安全状态时， 系统中一定无死锁进程", "C. 当系统处于不安全状态时，系统中一定会出现死锁进程", "D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件"],
                answer: "B",
                explanation: "银行家算法是死锁“避免”算法，不是预防。它通过确保系统始终处于安全状态来避免死锁。安全状态意味着存在一个序列能让所有进程完成，所以一定无死锁。故选B。"
            },
            {
                id: 30,
                question: "现有3个同时到达的作业J1、J2、J3，它们的执行时间分别为T1、T2、T3，且T1<T2<T3 。系统按单道方式运行且采用短作业优先算法，则平均周转时间是（ ）。",
                options: ["A. T1+T2+T3", "B. (T1+T2+T3)/3", "C. (3T1+2T2+T3)/3", "D. (T1+2T2+3T3)/3"],
                answer: "C",
                explanation: "SJF顺序：J1 -> J2 -> J3。\n周转时间：\nJ1: T1\nJ2: T1 + T2\nJ3: T1 + T2 + T3\n总周转: 3T1 + 2T2 + T3。平均值除以3。故选C。"
            },
            {
                id: 31,
                question: "下列事件中，可能引起进程调度程序执行的是( )。\n① 中断处理结束 ② 进程阻塞 ③ 进程执行结束 ④ 进程的时间片用完",
                options: ["A. 仅 ① 、 ③", "B. 仅 ② 、 ④", "C. 仅 ③ 、 ④", "D. ① 、 ② 、 ③ 和 ④"],
                answer: "D",
                explanation: "调度可以在以下情况触发：进程结束(③)、进程阻塞(②)、时间片用完(④)、中断返回(①, 如I/O中断可能唤醒高优先级进程导致抢占)。所有选项均正确。故选D。"
            },
            {
                id: 32,
                question: "假设4个作业到达系统的时刻和运行时间如下表所示。系统在t=2时开始作业调度。若分别采用先来先服务和短作业优先调度算法，则选中的作业分别是( )。",
                tableData: [
                    ["作业", "到达时刻t", "运行时间"],
                    ["J1", "0", "3"],
                    ["J2", "1", "3"],
                    ["J3", "1", "2"],
                    ["J4", "3", "1"]
                ],
                options: ["A. J2、J3", "B. J1、J4", "C. J2、J4", "D. J1、J3"],
                answer: "D",
                explanation: "t=2时，J1, J2, J3已到达，J4未到。\nFCFS（先来先服务）：看谁先到。J1(0)最早，选中J1。\nSJF（短作业优先）：在已到达的里面找最短。J3(2) < J1(3) = J2(3)，选中J3。\n故分别是J1和J3。选D。"
            },
            {
                id: 33,
                question: "进程P1、P2和P3进入就绪队列的时刻，优先值(越大优先权越高) 以及CPU的执行时间如下表所示。系统采用基于优先权的抢占式CPU调度算法，从0ms时刻开始进行调度，则P1、P2、P3的平均周转时间为( )。",
                tableData: [
                    ["进程名", "进入就绪队列的时刻", "优先数", "CPU的执行时间"],
                    ["p1", "0ms", "1", "60ms"],
                    ["p2", "20ms", "10", "42ms"],
                    ["p3", "30ms", "100", "13ms"]
                ],
                options: ["A. 60ms", "B. 61ms", "C. 70ms", "D. 71ms"],
                answer: "B",
                explanation: "抢占式分析：\n0-20ms: P1运行（剩余40）。\n20ms: P2(10)>P1(1)，抢占。P2运行。\n20-30ms: P2运行（剩余32）。\n30ms: P3(100)>P2(10)，抢占。P3运行。\n30-43ms: P3运行完。P3周转 = 43-30 = 13。\n43ms: P2继续运行（剩余32）。\n43-75ms: P2运行完。P2周转 = 75-20 = 55。\n75ms: P1继续运行（剩余40）。\n75-115ms: P1运行完。P1周转 = 115-0 = 115。\n平均 = (13+55+115)/3 = 61ms。故选B。"
            },
            {
                id: 34,
                question: "进程P0、P1、P2和P3进入就绪队列的时刻、优先级(值越小优先权越高)及CPU执行时间如下表所示。若系统采用基于优先权的抢占式进程调度算法，则从0ms时刻开始调度，到4个进程都运行结束为止，发生进程调度的总次数为（ ）。",
                tableData: [
                    ["进程", "进入就绪队列的时刻", "优先级", "CPU执行时间"],
                    ["P0", "0ms", "15", "100ms"],
                    ["P1", "10ms", "20", "60ms"],
                    ["P2", "10ms", "10", "20ms"],
                    ["P3", "15ms", "6", "10ms"]
                ],
                options: ["A. 4", "B. 5", "C. 6", "D. 7"],
                answer: "C",
                explanation: "值越小越优先。\n0ms: 调度P0 (1次)。\n10ms: P2(10)<P0(15)，抢占，调度P2 (2次)。\n15ms: P3(6)<P2(10)，抢占，调度P3 (3次)。\n25ms: P3完。剩下P2(10), P0(15), P1(20)。调度P2 (4次)。\n40ms: P2完（20-5+25? P2总需20，运行5被抢，剩15。25+15=40）。调度P0 (5次)。\n130ms: P0完。调度P1 (6次)。\n总共6次调度。故选C。"
            },
            {
                id: 35,
                question: "某系统采用基于优先权的非抢占式进程调度策略 ， 完成一次进程调度和进程切换的系统时间开销为1 µs。在T时刻就绪队列中有3个进程P1、P2和P3，其在就绪队列中的等待时间、需要的CPU时间和优先权如下表所示。若优先权值大的进程优先获得 CPU，从T时刻起系统开始进程调度，则系统的平均周转时间为( )。",
                tableData: [
                    ["进程", "等待时间", "需要的CPU时间", "优先权"],
                    ["P1", "30 μs", "12 μs", "10"],
                    ["P2", "15 μs", "24 μs", "30"],
                    ["P3", "18 μs", "36 μs", "20"]
                ],
                options: ["A. 54 μs", "B. 73 μs", "C. 74 μs", "D. 75 μs"],
                answer: "D",
                explanation: "非抢占，优先权: P2 > P3 > P1。顺序: P2 -> P3 -> P1。\n周转时间 = 已经在队列等待时间 + 还要等待前面的运行时间 + 自己的运行时间。\nP2: 15 + 24 = 39。\nP3: 18 + 24(等P2) + 36 = 78。\nP1: 30 + 24(P2) + 36(P3) + 12 = 102。\n平均 = (39+78+102)/3 = 73 μs。注：此处计算结果为73，但标准答案给出D (75)，可能是题目中“等待时间”的定义或隐含条件有细微差异（如是否包含T时刻前的某种开销）。考试时建议按标准答案D记忆，或检查题目数值印刷。"
            },
            {
                id: 36,
                question: "下列选项中，降低进程优先级的合理时机是( )。",
                options: ["A. 进程的时间片用完", "B. 进程刚完成I/ O ，进入就绪队列", "C. 进程长期处于就绪队列中", "D. 进程从就绪状态转为运行状态"],
                answer: "A",
                explanation: "时间片用完说明该进程是计算密集型（CPU繁忙），长时间占用CPU，为了公平，应降低其优先级。完成I/O通常应提高优先级（I/O繁忙型）。故选A。"
            },
            {
                id: 37,
                question: "某系统正在执行三个进程P1、P2和P3，各进程的计算(CPU)时间和I/ O 时间比例如下表所示。为提高系统资源利用率，合理的进程优先级设置应为( )。",
                tableData: [
                    ["进程", "计算时间", "I/O时间"],
                    ["P1", "90%", "10%"],
                    ["P2", "50%", "50%"],
                    ["P3", "15%", "85%"]
                ],
                options: ["A. P1>P2>P3", "B. P3>P2>P1", "C. P2>P1=P3", "D. P1>P2=P3"],
                answer: "B",
                explanation: "P3是I/O繁忙型（85%时间在I/O），P1是CPU繁忙型。为了让I/O设备尽早启动并与CPU并行工作，应优先调度I/O繁忙型进程。故 P3 > P2 > P1。选B。"
            },
            {
                id: 38,
                question: "下列有关基于时间片的进程调度的叙述中，错误的是( )。",
                options: ["A. 时间片越短，进程切换的次数越多，系统开销也越大", "B. 当前进程的时间片用完后，该进程状态由执行态变为阻塞态", "C. 时钟中断发生后，系统会修改当前进程在时间片内的剩余时间", "D. 影响时间片大小的主要因素包括响应时间、系统开销和进程数量等"],
                answer: "B",
                explanation: "时间片用完后，进程是被强制剥夺CPU，状态由“执行态”变为“就绪态”等待下一次调度，而不是“阻塞态”。阻塞通常是主动等待事件。故选B。"
            },
            {
                id: 39,
                question: "下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是( )。\n① 进程控制块 ② 时钟中断处理程序 ③ 进程就绪队列 ④ 进程阻塞队列",
                options: ["A. 仅 ② 、 ③", "B. 仅 ① 、 ④", "C. 仅 ① 、 ② 、 ③", "D. 仅 ① 、 ② 、 ④"],
                answer: "C",
                explanation: "时间片轮转核心：PCB(①)记录进程状态；时钟中断(②)进行倒计时和触发切换；就绪队列(③)组织轮转的进程。阻塞队列不是轮转调度的直接组成部分（虽然系统里有）。故选C。"
            },
            {
                id: 40,
                question: "下列调度算法中，不可能导致饥饿现象的是( )。",
                options: ["A. 时间片轮转", "B. 静态优先数调度", "C. 非抢占式短作业优先", "D. 抢占式短作业优先"],
                answer: "A",
                explanation: "时间片轮转（RR）强制轮流执行，每个进程都能获得CPU，绝对公平，不会饥饿。优先级和SJF都可能让低优先级或长作业无限等待。故选A。"
            },
            {
                id: 41,
                question: "下列选项中，满足短任务优先且不会发生饥饿现象的调度算法是( )。",
                options: ["A. 先来先服务", "B. 高响应比优先", "C. 时间片轮转", "D. 非抢占式短任务优先"],
                answer: "B",
                explanation: "高响应比优先算法的优先权 = (等待时间+服务时间)/服务时间。短任务服务时间小，优先权高（满足短任务优先）；长任务随着等待时间增加，优先权也会提高，最终获得执行（避免饥饿）。故选B。"
            },
            {
                id: 42,
                question: "一个进程的读磁盘操作完成后，操作系统针对该进程必做的是( )。",
                options: ["A. 修改进程状态为就绪态", "B. 降低进程优先级", "C. 给进程分配用户内存空间", "D. 增加进程时间片大小"],
                answer: "A",
                explanation: "I/O操作（读磁盘）完成后，进程从阻塞状态被唤醒，变为就绪状态，准备接受调度。故选A。"
            },
            {
                id: 43,
                question: "系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10 ms；就绪队列Q2 采用短进程优先调度算法；系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的CPU时间分别为30 ms和20ms，则进程P1 、P2在系统中的平均等待时间为( )。",
                options: ["A. 25 ms", "B. 20 ms", "C. 15 ms", "D. 10 ms"],
                answer: "C",
                explanation: "P1先到，运行10ms (剩20)，入Q2。\nP2随后到，运行10ms (剩10)，入Q2。\n此时Q1空，调度Q2。Q2按SJF调度。\nP2(10) < P1(20)，先调度P2。\nP2运行10ms完成。P2等待时间 = 10ms (在Q2等P1运行的时间? 不对，P2在Q1运行完立刻进Q2，此时P1已在Q2。P2在Q1等了P1的10ms吗？题目说依次创建，通常认为0时刻都在或紧接着。若0时刻都在：P1跑10ms时P2在等(10)。P2跑10ms时P1在等(10)。然后Q2里P2先跑，P1又等(10)。\nP2等待: 10(Q1) + 0(Q2) = 10。\nP1等待: 0(Q1) + 10(等P2 Q1) + 10(等P2 Q2) = 20。\n平均 = (10+20)/2 = 15ms。故选C。"
            },
            {
                id: 44,
                question: "下列与进程有关的因素中，在设计多级反馈队列调度算法时需要考虑的是( )。\n① 就绪队列的数量 ② 就绪队列的优先级 ③ 各就绪队列的调度算法 ④ 进程在就绪队列间的迁移条件",
                options: ["A. 仅 ① 、 ②", "B. 仅 ③ 、 ④", "C. 仅 ② 、 ③ 、 ④", "D. ① 、 ② 、 ③ 和 ④"],
                answer: "D",
                explanation: "多级反馈队列算法的设计参数正是这四个：队列数、每个队列的优先级、每个队列内部的算法（通常RR或FCFS）、以及何时升级或降级。故选D。"
            },
            {
                id: 45,
                question: "若系统中有n(n≥2)个进程，每个进程均需要使用某类临界资源2个，则系统不会发生死锁所需的该类资源总数至少是( )。",
                options: ["A. 2", "B. n", "C. n+1", "D. 2n"],
                answer: "C",
                explanation: "最不利情况：每个进程都获得1个资源，共消耗n个，发生死锁。只要再多1个资源，就能让其中一个进程满足需求（2个），运行完释放资源，死锁解开。故 n+1。选C。"
            },
            {
                id: 46,
                question: "某计算机系统中有8台打印机，由K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值是( )。",
                options: ["A. 2", "B. 3", "C. 4", "D. 5"],
                answer: "C",
                explanation: "利用死锁公式：K * (N-1) + 1 <= Total 不死锁。\n这里 N=3。每个进程占2个。\nK=3: 3*2=6 < 8，不死锁。\nK=4: 4*2=8，资源耗尽，此时若大家都请求第3个，死锁。故K最小为4。选C。"
            },
            {
                id: 47,
                question: "某系统有n台互斥使用的同类设备 ， 三个并发进程分别需要3、4、5台设备，可确保系统不发生死锁的设备数m最小为( )。",
                options: ["A. 9", "B. 10", "C. 11", "D. 12"],
                answer: "B",
                explanation: "最坏情况：所有进程都拿到了“最大需求-1”。\n(3-1) + (4-1) + (5-1) = 2 + 3 + 4 = 9。\n此时系统耗尽，死锁。再多1台设备，就能满足其中一个进程。故 m = 9 + 1 = 10。选B。"
            },
            {
                id: 48,
                question: "下列关于死锁的叙述中，正确的是( )。\n① 可以通过剥夺进程资源解除死锁\n② 死锁的预防方法能确保系统不发生死锁\n③ 银行家算法可以判断系统是否处于死锁状态\n④ 当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态",
                options: ["A. 仅 ② 、 ③", "B. 仅 ① 、 ② 、 ④", "C. 仅 ① 、 ② 、 ③", "D. 仅 ① 、 ③ 、 ④"],
                answer: "B",
                explanation: "①正确，剥夺资源是解除死锁的方法之一；②正确，预防通过破坏必要条件杜绝死锁；③错误，银行家算法是“避免”死锁，通过试探分配保证安全，而不是判断当前是否已死锁（那是死锁检测）；④正确，死锁是循环等待，至少涉及两个进程。故选B。"
            },
            {
                id: 49,
                question: "系统中有3个不同的临界资源R1、R2和R3，被4个进程p1、p2、p3和p4共享。各进程对资源的需求：p1申请R1和R2，p2申请R2和R3，p3申请R1和R3，p4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是( )。",
                options: ["A. 1", "B. 2", "C. 3", "D. 4"],
                answer: "C",
                explanation: "死锁定义上至少2个。但根据资源分配图的环路分析，本题的具体资源依赖关系（P1需要R1,R2等）会导致最小环路涉及3个进程。故选C。"
            },
            {
                id: 50,
                question: "若系统S1采用死锁避免方法，S2采用死锁检测方法。下列叙述中，正确的是( )。\n① S1会限制用户申请资源的顺序，而S2不会\n② S1需要进程运行所需资源总量信息，而S2不需要\n③ S1不会给可能导致死锁的进程分配资源，而S2会",
                options: ["A. 仅 ① 、 ②", "B. 仅 ② 、 ③", "C. 仅 ① 、 ③", "D. ① 、 ② 、 ③"],
                answer: "B",
                explanation: "①错，限制申请顺序是“死锁预防”（有序分配），避免算法（如银行家）不限制顺序；②对，银行家算法需要预知Max需求；③对，避免算法会拒绝不安全分配，检测算法允许分配直到检测出死锁。故选B。"
            },

            // --- Part 3: Memory Management (Questions 51-75) ---
            {
                id: 51,
                question: "设内存的分配情况如图所示。若要申请一块40K的内存空间，采用最佳适应算法，则所得到的分区首址是（ ）。",
                tableData: [
                    ["起始地址", "状态", "大小/结束标记"],
                    ["0", "操作系统", ""],
                    ["100K", "(空闲)", "80K"],
                    ["180K", "占用", ""],
                    ["190K", "(空闲)", "90K"],
                    ["280K", "占用", ""],
                    ["330K", "(空闲)", "60K"],
                    ["390K", "占用", ""],
                    ["410K", "(空闲)", "102K-1"],
                    ["512K-1", "", ""]
                ],
                options: ["A. 100K", "B. 190K", "C. 330K", "D. 410K"],
                answer: "C",
                explanation: "最佳适应算法（Best Fit）要求选择能满足需求且大小最小的空闲分区。空闲分区有：80K, 90K, 60K, 102K。申请40K，这四个都能满足，其中60K最小。60K分区的起始地址是330K。故选C。"
            },
            {
                id: 52,
                question: "某基于动态分区存储管理的计算机，其主存容量为55 MB(初始为空闲)，采用最佳适配(Best Fit)算法 ， 分配和释放的顺序 ： 分配15 MB ， 分配30 MB ， 释放15 MB ， 分配8 MB ， 分配6 MB。此时主存中最大空闲分区的大小是( )。",
                options: ["A. 7MB", "B. 9MB", "C. 10MB", "D. 15MB"],
                answer: "B",
                explanation: "初始55。\n1. 分15 -> 剩40。\n2. 分30 -> 剩10。\n3. 释15 -> 空闲: 15, 10。\n4. 分8 -> 最佳适配找10，切出8，剩2。空闲: 15, 2。\n5. 分6 -> 最佳适配找15，切出6，剩9。空闲: 9, 2。\n最大空闲是9MB。故选B。"
            },
            {
                id: 53,
                question: "某计算机采用二级页表的分页存储管理方式，按字节编制，页大小为1KB，页表项大小为2B，逻辑地址结构如下。逻辑地址空间大小为2的16次方个页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是（ ）。",
                tableData: [["页目录号", "页号", "页内偏移量"]],
                options: ["A. 64", "B. 128", "C. 256", "D. 512"],
                answer: "B",
                explanation: "页大小 1KB (2^10)，页表项 2B。一页可存 1KB/2B = 512 (2^9) 个页表项。\n总逻辑页数 2^16。\n每个二级页表可以管理 512 (2^9) 个页面。\n需要的二级页表数量 = 总页数 / 一个页表管理的页数 = 2^16 / 2^9 = 2^7 = 128。\n一级页表（页目录）需要为这 128 个二级页表各提供一个表项，所以至少 128 个。故选B。"
            },
            {
                id: 54,
                question: "在一个段式存储管理系统中，段表内容如下表所示。一个逻辑地址为（2, 154B），它对应的物理地址是（ ）。",
                tableData: [
                    ["段号", "段首地址", "段长度"],
                    ["0", "120K", "40K"],
                    ["1", "760K", "30K"],
                    ["2", "480K", "20K"],
                    ["3", "370K", "20K"]
                ],
                options: ["A. 120K+2B", "B. 480K+154B", "C. 30K+154B", "D. 480K+2B"],
                answer: "B",
                explanation: "逻辑地址(段号S, 偏移W) = (2, 154B)。\n查表得段2：基址 480K，长度 20K。\n检查越界：154B < 20K，合法。\n物理地址 = 基址 + 偏移 = 480K + 154B。故选B。"
            },
            {
                id: 55,
                question: "动态重定位是在作业的（ ）中进行的。",
                options: ["A. 编译过程", "B. 装入过程", "C. 链接过程", "D. 执行过程"],
                answer: "D",
                explanation: "动态重定位依赖硬件（重定位寄存器），地址转换发生在指令“执行”时。装入时只是把代码装入内存，不修改地址。故选D。"
            },
            {
                id: 56,
                question: "在动态分区分配方案中 ， 某一作业完成后 ， 系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是( )。",
                options: ["A. 无上邻空闲区 ， 也无下邻空闲区", "B. 有上邻空闲区 ， 但无下邻空闲区", "C. 有下邻空闲区 ， 但无上邻空闲区", "D. 有上邻空闲区 ， 也有下邻空闲区"],
                answer: "D",
                explanation: "A情况：增加一个新空闲项（+1）。\nB、C情况：与一个相邻合并，数量不变（0）。\nD情况：与上下都合并，三合一，空闲区数量减少1个（-1）。故选D。"
            },
            {
                id: 57,
                question: "下面的存储管理方案中，（ ）方式可以采用静态重定位。",
                options: ["A. 固定分区", "B. 可变分区", "C. 页式", "D. 段式"],
                answer: "A",
                explanation: "固定分区在装入时就确定了绝对地址，适合静态重定位。其他方式通常需要支持移动或离散存储，采用动态重定位。故选A。"
            },
            {
                id: 58,
                question: "不会产生内部碎片的存储管理是（ ）。",
                options: ["A. 分页", "B. 分段", "C. 段页式", "D. 固定分区"],
                answer: "B",
                explanation: "分段是按逻辑单位划分的，段长可变，正好放入内存区，因此没有内部碎片（但会产生外部碎片）。分页和固定分区都有固定的块大小，最后一块通常装不满，产生内部碎片。故选B。"
            },
            {
                id: 59,
                question: "在不使用快表的情况下，基本段页式内存管理系统中 ， 访问一条指令需要几次访问内存? ( )。",
                options: ["A. 3", "B. 0", "C. 1", "D. 2"],
                answer: "A",
                explanation: "1. 访问段表，获得页表起始地址；2. 访问页表，获得物理块号；3. 访问物理内存，读取指令。共3次。故选A。"
            },
            {
                id: 60,
                question: "虚拟存储管理系统的基础是程序的（ ）理论。",
                options: ["A. 动态性", "B. 虚拟性", "C. 局部性", "D. 全局性"],
                answer: "C",
                explanation: "局部性原理（时间局部性和空间局部性）表明程序在执行时往往只访问局部区域，这使得部分装入和页面置换成为可能，是虚拟存储的理论基础。故选C。"
            },
            {
                id: 61,
                question: "对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是( )。",
                options: ["A. 每个进程都有自已独立的虚拟地址空间", "B. C语言中malloc()函数返回的是虚拟地址", "C. 进程对数据段和代码段可以有不同的访问权限", "D. 虚拟地址的大小由主存和硬盘的大小决定"],
                answer: "D",
                explanation: "虚拟地址空间的大小由CPU的寻址能力（如32位或64位）决定，与实际的物理内存和硬盘大小无关。故选D。"
            },
            {
                id: 62,
                question: "下列选项中，不会影响系统缺页率的是（ ）。",
                options: ["A. 页置换算法", "B. 工作集的大小", "C. 进程的数量", "D. 页缓冲队列的长度"],
                answer: "D",
                explanation: "页缓冲队列是已淘汰页面的缓存，影响的是缺页后的有效访问时间（EAT，能不能快点找回来），但不影响缺页中断本身的发生频率。A、B、C都直接影响内存分配和页面命中。故选D。"
            },
            {
                id: 63,
                question: "在页式虚拟存储管理系统中，采用某些页面置换算法，会出现Belady异常现象，即进程的缺页次数会随着分配给该进程的页框个数 的增加而 增加。下列算法中：① LRU算法 ②FIFO算法 ③OPT算法，可能出现Belady异常现象的是（ ）。",
                options: ["A. 仅②", "B. 仅①、②", "C. 仅①、③", "D. 仅②、③"],
                answer: "A",
                explanation: "Belady异常是FIFO（先进先出）算法特有的现象。LRU和OPT属于堆栈类算法，理论上保证页框越多缺页越少。故选A。"
            },
            {
                id: 64,
                question: "某进程访问的页 b 不在内存中，导致产生缺页异常，该缺页异常处理过程中不一定包含的操作是（ ）。",
                options: ["A. 淘汰内存中的页", "B. 建立页号与页框号的对应关系", "C. 将页 b 从外存读入内存", "D. 修改页表中页 b 对应的存在位"],
                answer: "A",
                explanation: "如果内存中还有空闲页框，直接调入即可，不需要“淘汰”现有页面。其他B、C、D是缺页处理的必经步骤。故选A。"
            },
            {
                id: 65,
                question: "多进程能在主存中彼此互不干扰的环境下运行，OS是通过（ ）来实现的。",
                options: ["A. 内存分配", "B. 内存保护", "C. 内存扩充", "D. 地址映射"],
                answer: "B",
                explanation: "内存保护机制（如基址限长寄存器、保护键等）防止进程访问属于其他进程或操作系统的地址空间，实现互不干扰。故选B。"
            },
            {
                id: 66,
                question: "在缺页处理过程中，操作系统执行的操作可能是（ ）。\n①修改页表    ②磁盘I/O    ③分配页框",
                options: ["A. 仅①、②", "B. 仅②", "C. 仅③", "D. ①、②、③"],
                answer: "D",
                explanation: "缺页发生时，OS需要：分配物理块(③)，启动磁盘读入页面(②)，更新页表记录映射关系(①)。故选D。"
            },
            {
                id: 67,
                question: "某请求分页存储系统的页大小为4KB，按字节编址。系统给进程P分配2个固定的页框,并采用改进型Clock置换算法，进程P页表的部分内容如下表所示。若P访问虚拟地址为02A01H的存储单元，则经地址变换后得到的物理地址是( )。",
                tableData: [
                    ["页号", "页框号", "存在位 (1: 存在，0: 不存在)", "访问位 (1: 访问，0: 未访问)", "修改位 (1: 修改，0: 未修改)"],
                    ["...", "...", "...", "...", "..."],
                    ["2", "20H", "0", "0", "0"],
                    ["3", "60H", "1", "1", "0"],
                    ["4", "80H", "1", "1", "1"],
                    ["...", "...", "...", "...", "..."]
                ],
                options: ["A. 00A01H", "B. 20A01H", "C. 60A01H", "D. 80A01H"],
                answer: "C",
                explanation: "页大小4KB -> 页内偏移占12位。虚拟地址 02A01H，低12位 A01H 是偏移，高位 02H 是页号。\n查表：页号2 存在位0（不在内存），本应缺页。但题目选项给出了物理地址，且C选项 60A01H 对应页框 60H。\n查表发现页框 60H 对应的是页号 3。这通常意味着题目的虚拟地址应该是 03A01H，或者是印刷错误。根据选项反推，匹配页框 60H 的是页号3。物理地址 = 页框号拼接偏移 = 60A01H。故选C。"
            },
            {
                id: 68,
                question: "在采用二级页表的分页系统中，CPU页表基址寄存器中的内容是( )。",
                options: ["A. 当前进程的一级页表的起始虚拟地址", "B. 当前进程的一级页表的起始物理地址", "C. 当前进程的二级页表的起始虚拟地址", "D. 当前进程的二级页表的起始物理地址"],
                answer: "B",
                explanation: "页表基址寄存器(PTBR)供硬件MMU直接访问内存使用，必须存储物理地址，且指向最高级页表（一级页表/页目录）。故选B。"
            },
            {
                id: 69,
                question: "某计算机主存按字节编址，采用二级分页存储管理，地址结构如下所示。虚拟地址2050 1225H对应的页目录号、页号分别是( )。",
                tableData: [["页目录号 (10 位)", "页号 (10) 位", "页内偏移 (12 位)"]],
                options: ["A. 081H、101H", "B. 081H、401H", "C. 201H、101H", "D. 201H、401H"],
                answer: "A",
                explanation: "将十六进制地址转为二进制：\n2050 1225 H = 0010 0000 0101 0000 0001 0010 0010 0101\n偏移量(低12位): 0010 0010 0101 (225H)\n页号(中间10位): 01 0000 0001 -> 101H\n页目录号(高10位): 00 1000 0001 -> 081H\n故选A。"
            },
            {
                id: 70,
                question: "在可变式分区存储管理中的紧凑技术可以（ ）。",
                options: ["A. 集中空闲区", "B. 增加主存容量", "C. 缩短访问周期", "D. 加速地址转换"],
                answer: "A",
                explanation: "紧凑（Compaction）通过移动内存中的作业，将分散的小空闲分区合并成一个大的空闲分区，解决外部碎片问题。故选A。"
            },
            {
                id: 71,
                question: "虚拟存储管理策略可以（ ）。",
                options: ["A. 扩大逻辑内存容量", "B. 扩大物理内存容量", "C. 扩大逻辑外存容量", "D. 扩大物理外存容量"],
                answer: "A",
                explanation: "虚拟存储使用外存模拟内存，让用户程序认为系统有比实际物理内存大得多的内存空间，即扩大了逻辑内存容量。故选A。"
            },
            {
                id: 72,
                question: "一般情况下，请求分页存储管理方式中，页面大小增加一倍则缺页中断次数（ ）。",
                options: ["A. 增加", "B. 减少", "C. 不变", "D. 可能增加也可能减少"],
                answer: "B",
                explanation: "页面变大，每个页面包含的信息更多，局部性更好，因此缺页率通常会降低（减少）。（注：过大可能导致抖动，但“一般情况”下是减少）。故选B。"
            },
            {
                id: 73,
                question: "下列选项中，属于多级页表优点的是( )。",
                options: ["A. 加快地址变换速度", "B. 减少缺页中断次数", "C. 减少页表项所占字节数", "D. 减少页表所占的连续内存空间"],
                answer: "D",
                explanation: "多级页表增加了访存次数（速度变慢），但它允许页表被离散存储，且不需要一次性将所有页表调入内存，解决了大页表需要占用大片连续内存的问题。故选D。"
            },
            {
                id: 74,
                question: "在虚拟存储系统中，若进程在内存中占3块（开始时为空），采用先进先出页面淘汰算法，当执行访问页号序列为1、2、3、4、1、2、5、1、2、3、4、5、6时，将产生 （ ） 次缺页中断。",
                options: ["A. 7", "B. 8", "C. 9", "D. 10"],
                answer: "D",
                explanation: "FIFO过程：\n1(缺), 2(缺), 3(缺) -> [1,2,3]\n4(缺) -> 换1 [4,2,3]\n1(缺) -> 换2 [4,1,3]\n2(缺) -> 换3 [4,1,2]\n5(缺) -> 换4 [5,1,2]\n1(中), 2(中)\n3(缺) -> 换5 [3,1,2]\n4(缺) -> 换1 [3,4,2]\n5(缺) -> 换2 [3,4,5]\n6(缺) -> 换3 [6,4,5]\n总计缺页：1,2,3,4,1,2,5,3,4,5,6，共10次。故选D。"
            },
            {
                id: 75,
                question: "系统为某进程分配了4个页框 ， 该进程已访问的页号序列为2 、 0 、 2 、 9 、 3 、 4 、 2 、 8 、 2 、 4 、 8 、 4 、 5。若进程要访问的下一页的页号为7 ， 依据 LRU 算法 ， 应淘汰页的页号是 （ ）。",
                options: ["A. 2", "B. 3", "C. 4", "D. 8"],
                answer: "A",
                explanation: "LRU看最近最少使用。向前看最后访问的4个不同页号：\n5 (最近)\n4\n8\n2\n... (3在更前面)\n内存中是 {5, 4, 8, 2}。按最近使用排序：5>4>8>2。最老的页是2。故选A。"
            },

            // --- Part 4: File & I/O Management (Questions 76-100) ---
            {
                id: 76,
                question: "文件系统中用（ ）管理文件。",
                options: ["A. 作业控制块", "B. 外页表", "C. 目录", "D. 软硬件结合的方法"],
                answer: "C",
                explanation: "文件系统通过文件目录（Directory）和FCB来管理文件的检索和属性。故选C。"
            },
            {
                id: 77,
                question: "如果文件系统中有两个文件重名，不应采用（ ）。",
                options: ["A. 单级目录结构", "B. 树型目录结构", "C. 二级目录结构", "D. 非循环图目录结构"],
                answer: "A",
                explanation: "单级目录结构中，所有文件都在同一个表中，不允许重名。其他结构通过路径区分，允许重名。故选A。"
            },
            {
                id: 78,
                question: "下列选项中，支持文件长度可变、随机访问的磁盘存储空间分配方式是( )。",
                options: ["A. 索引分配", "B. 链接分配", "C. 连续分配", "D. 动态分区分配"],
                answer: "A",
                explanation: "连续分配支持随机但不支持变长（扩展难）；链接分配支持变长但不支持随机；索引分配既支持随机（查索引表），也支持变长（增加索引项）。故选A。"
            },
            {
                id: 79,
                question: "采用直接存取方法来读写硬盘上的物理记录时，效率最低的文件结构是( )。",
                options: ["A. 连续文件", "B. 索引文件", "C. 链接文件", "D. 索引连续文件"],
                answer: "C",
                explanation: "直接存取要求能快速定位到第i块。链接文件（链式）必须从头遍历指针，无法直接跳转，效率最低。故选C。"
            },
            {
                id: 80,
                question: "在磁盘上容易导致存储碎片发生的物理文件结构是（ ） 。",
                options: ["A. 链接文件", "B. 连续文件", "C. 索引文件", "D. 索引和链接文件"],
                answer: "B",
                explanation: "连续文件要求连续的磁盘空间，容易产生外部碎片（磁盘空洞），需要紧凑整理。故选B。"
            },
            {
                id: 81,
                question: "UNIX系统中对空闲磁盘存储空间采用( )方法管理。",
                options: ["A. 位示图", "B. 空闲块成组链接", "C. 空闲块单向链接", "D. 空闲块表"],
                answer: "B",
                explanation: "UNIX系统采用成组链接法（Group Linked List），适合大型文件系统，效率高。故选B。"
            },
            {
                id: 82,
                question: "为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式（ ）。",
                options: ["A. 连续结构", "B. 链式结构", "C. 直接索引结构", "D. 多级索引结构"],
                answer: "A",
                explanation: "虽然题目提到“随机播放”，但光盘的寻道时间极长。连续结构能最大程度减少磁头移动，保证视频流的连续高带宽读取。故选A。"
            },
            {
                id: 83,
                question: "若某文件系统索引节点(inode)中有直接地址项和间接地址项，则下列选项中，与单个文件长度无关的因素是( )。",
                options: ["A. 索引节点的总数", "B. 间接地址索引的级数", "C. 地址项的个数", "D. 文件块大小"],
                answer: "A",
                explanation: "单个文件的最大长度由它能索引多少个数据块决定（受地址项个数、级数、块大小影响）。“索引节点的总数”决定了系统能存多少个文件，与单个文件大小无关。故选A。"
            },
            {
                id: 84,
                question: "一个系统，它的文件控制块占64B，一个磁盘块大小为1KB，采用一级目录。假定文件目录中有3200个目录项。问查找一个文件平均需要（ ）次访问磁盘。",
                options: ["A. 50", "B. 54", "C. 100", "D. 200"],
                answer: "C",
                explanation: "一页存FCB数 = 1024/64 = 16个。\n3200个FCB占用的页数 = 3200/16 = 200页。\n顺序查找平均访问 = 200/2 = 100次。故选C。"
            },
            {
                id: 85,
                question: "某文件系统的簇（块）和磁盘扇区大小分别为1 KB和512B。若一个文件的大小为1026B，则系统分配给该文件的磁盘空间大小是( )。",
                options: ["A. 1026B", "B. 1536B", "C. 1538B", "D. 2048B"],
                answer: "D",
                explanation: "簇是分配的最小单位。1簇=1KB=1024B。\n文件1026B > 1024B，需占用2个簇。\n总空间 = 2 * 1024B = 2048B。故选D。"
            },
            {
                id: 86,
                question: "下列选项中，可用于文件系统管理空闲磁盘块的数据结构是( )。\n①位图 ②索引节点 ③空闲磁盘块链 IV.文件分配表(FAT)",
                options: ["A. 仅①②", "B. 仅①③④", "C. 仅①③", "D. 仅②③④"],
                answer: "B",
                explanation: "①位图、③空闲链表、④FAT（隐式链表）都是空闲管理方法。②索引节点是管理文件的，不是管理空闲块的。故选B。"
            },
            {
                id: 87,
                question: "设文件索引节点中有7个地址项，其中4个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引，每个地址项大小为4字节，若磁盘索引块和磁盘数据块大小均为256字节，则可表示的单个文件的最大长度是（ ）。",
                options: ["A. 33KB", "B. 519KB", "C. 1057KB", "D. 16513KB"],
                answer: "C",
                explanation: "直接：4 * 256B = 1KB。\n一级：2 * (256/4) * 256B = 2 * 64 * 256B = 32KB。\n二级：1 * (256/4) * (256/4) * 256B = 4096 * 256B = 1024KB。\n总计：1 + 32 + 1024 = 1057KB。故选C。"
            },
            {
                id: 88,
                question: "假设某个文件的索引节点已在内存，其他信息均在外存，为了访问该文件的某内容，直接寻址、一次间接、二次间接、三次间接分别需要几次访盘？（ ）",
                options: ["A. 0,1,2,3", "B. 1,2,3,4", "C. 2,3,4,5", "D. 1,3,4,5"],
                answer: "B",
                explanation: "直接：读数据(1次)。\n一次间接：读索引+读数据(2次)。\n二次间接：读一级+读二级+读数据(3次)。\n三次间接：读一级+读二级+读三级+读数据(4次)。\n故选B。"
            },
            {
                id: 89,
                question: "某文件系统的目录项由文件名和索引节点号构成。若每个目录项长度为64字节，其中4个字节存放索引节点号 ， 60个字节存放文件名，文件名由小写英文字母构成，则该文件系统能创建的文件数量的上限为( )。",
                options: ["A. 2^26", "B. 2^32", "C. 2^60", "D. 2^64"],
                answer: "B",
                explanation: "文件数量上限受限于索引节点号的寻址范围。索引节点号占4字节（32位），故最大可表示 2^32 个不同文件。故选B。"
            },
            {
                id: 90,
                question: "现有一个容量为10GB的磁盘分区，磁盘空间以簇(Cluster)为单位进行分配，簇的大小为4KB ， 若采用位图法管理该分区的空闲空间，即用一位(bit)标识 一 个簇是否被分配，则存放该位图所需簇的个数为( )。",
                options: ["A. 80", "B. 320", "C. 80K", "D. 320K"],
                answer: "A",
                explanation: "总簇数 = 10GB / 4KB = 2.5M (2,621,440)。\n位图大小 = 2,621,440 bits = 327,680 Bytes。\n占用簇数 = 327,680 / 4096 ≈ 80 个簇。故选A。"
            },
            {
                id: 91,
                question: "引入高速缓冲的主要目的是（ ）。",
                options: ["A. 提高CPU的利用率", "B. 提高I/O设备的利用率", "C. 改善CPU和I/O设备之间速度不匹配的情况", "D. 节省内存"],
                answer: "C",
                explanation: "缓冲技术主要为了解决高速CPU与低速I/O设备之间的速度差异，减少中断次数。故选C。"
            },
            {
                id: 92,
                question: "CPU输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可采用（ ）。",
                options: ["A. 并行技术", "B. 通道技术", "C. 缓冲技术", "D. 虚存技术"],
                answer: "C",
                explanation: "缓冲技术（Buffering）直接解决速度匹配问题。SPOOLing也是基于缓冲的，但选项中缓冲更基础。故选C。"
            },
            {
                id: 93,
                question: "通道相当于小型处理机，它用于实现（ ）之间的信息传输。",
                options: ["A. 内存与外设", "B. CPU与外设", "C. 内存与外存", "D. CPU与外存"],
                answer: "A",
                explanation: "通道是I/O专用处理器，负责控制内存与外设（含外存）之间的数据传输，释放CPU。故选A。"
            },
            {
                id: 94,
                question: "以时间换空间或者以空间换时间是操作系统的基本技术，以下属于以空间换时间的机制是( )。",
                options: ["A. SPOOLing", "B. 虚拟存储技术", "C. 通道技术", "D. 覆盖技术"],
                answer: "A",
                explanation: "SPOOLing利用磁盘空间作为缓冲区（Space），让CPU无需等待低速设备（Saving Time），是以空间换时间。虚拟存储是以时间换空间。故选A。"
            },
            {
                id: 95,
                question: "通过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为（ ）。",
                options: ["A. 存储设备", "B. 系统设备", "C. 用户设备", "D. 虚拟设备"],
                answer: "D",
                explanation: "SPOOLing技术将独占设备虚拟化，称为虚拟设备。故选D。"
            },
            {
                id: 96,
                question: "在（ ）I/ O 控制方式中，设备能直接与内存交换数据而不占用CPU。",
                options: ["A. 轮询", "B. 中断", "C. DMA", "D. MMU"],
                answer: "C",
                explanation: "DMA（直接存储器访问）方式下，数据传送由DMA控制器控制，直接在内存和外设间进行，不占用CPU。故选C。"
            },
            {
                id: 97,
                question: "某系统中磁盘的磁道数为200(0~199)，磁头当前在184号磁道上。用户进程提出的磁盘访问请求对应的磁道号依次为184、 187、176、182、199。若采用最短寻道时间优先调度算法(SSTF)完成磁盘访问，则磁头移动的距离(磁道数)是( )。",
                options: ["A. 37", "B. 38", "C. 41", "D. 42"],
                answer: "C",
                explanation: "SSTF顺序：184(0) -> 182(2) -> 187(5) -> 176(11) -> 199(23)。\n总移动：2+5+11+23 = 41。故选C。"
            },
            {
                id: 98,
                question: "在以下磁盘调度算法中，（ ）算法可能会随时改变移动臂的运动方向 。",
                options: ["A. 最短寻道时间优先", "B. 扫描SCAN（双向扫描）", "C. 巡回扫描C-SCAN（单向扫描）", "D. 都不会"],
                answer: "A",
                explanation: "SSTF只找最近的，可能忽左忽右（左右横跳）。SCAN和C-SCAN都有固定方向。故选A。"
            },
            {
                id: 99,
                question: "一个计算机系统配置了2台同类绘图机和3台同类打印机。为了正确驱动这些设备，系统应该提供（ ）个设备驱动程序。",
                options: ["A. 5", "B. 3", "C. 2", "D. 1"],
                answer: "C",
                explanation: "驱动程序针对设备类型（Type）。同类设备共用一个驱动。2种类型 = 2个驱动。故选C。"
            },
            {
                id: 100,
                question: "磁盘调度的目的是为了缩短（ ）时间。",
                options: ["A. 寻道", "B. 延迟", "C. 传送", "D. 启动"],
                answer: "A",
                explanation: "磁盘访问时间中，寻道时间（机械移动）最长且可被调度优化。旋转和传输主要受硬件限制。故选A。"
            }
        ];

        function App() {
            const [currentQIndex, setCurrentQIndex] = useState(0);
            const [userAnswers, setUserAnswers] = useState({});
            const [showExplanation, setShowExplanation] = useState(false);
            const [correctCount, setCorrectCount] = useState(0);
            
            const mainContentRef = useRef(null);

            const handleAnswer = (optionChar) => {
                if (userAnswers[currentQIndex]) return;

                const isCorrect = optionChar === questionsData[currentQIndex].answer;
                setUserAnswers(prev => ({
                    ...prev,
                    [currentQIndex]: { selected: optionChar, isCorrect: isCorrect }
                }));

                if (isCorrect) setCorrectCount(c => c + 1);
            };

            const scrollToTop = () => {
                if (mainContentRef.current) {
                    mainContentRef.current.scrollTo({ top: 0, behavior: 'smooth' });
                }
            };

            const nextQuestion = () => {
                if (currentQIndex < questionsData.length - 1) {
                    setCurrentQIndex(c => c + 1);
                    setShowExplanation(false);
                    setTimeout(scrollToTop, 100);
                }
            };

            const prevQuestion = () => {
                if (currentQIndex > 0) {
                    setCurrentQIndex(c => c - 1);
                    setShowExplanation(false);
                    setTimeout(scrollToTop, 100);
                }
            };

            const jumpToQuestion = (index) => {
                setCurrentQIndex(index);
                setShowExplanation(false);
                setTimeout(scrollToTop, 100);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowRight') nextQuestion();
                    if (e.key === 'ArrowLeft') prevQuestion();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentQIndex]);

            const currentQ = questionsData[currentQIndex];
            const currentAns = userAnswers[currentQIndex];

            return (
                <div className="flex h-screen overflow-hidden bg-gray-50">
                    {/* Sidebar */}
                    <aside className="w-64 bg-white border-r border-gray-200 flex flex-col flex-shrink-0 z-10 shadow-lg hidden md:flex">
                        <div className="p-5 border-b border-gray-100 bg-gray-50">
                            <h1 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                                <span>📚</span> OS 复习题库
                            </h1>
                            <div className="mt-4 text-xs font-medium text-gray-500 flex justify-between items-center bg-white p-2 rounded border border-gray-100">
                                <span>进度: {Object.keys(userAnswers).length} / {questionsData.length}</span>
                                <span className={`${correctCount > 0 ? 'text-green-600' : 'text-gray-400'}`}>
                                    {Object.keys(userAnswers).length > 0 ? Math.round((correctCount / Object.keys(userAnswers).length) * 100) : 0}% 正确
                                </span>
                            </div>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto p-4 sidebar-scroll">
                            <div className="grid grid-cols-5 gap-2">
                                {questionsData.map((q, idx) => {
                                    const ans = userAnswers[idx];
                                    let bgClass = "bg-white border-gray-200 text-gray-600 hover:bg-gray-100 hover:border-blue-300";
                                    if (ans) {
                                        bgClass = ans.isCorrect 
                                            ? "bg-green-500 border-green-600 text-white shadow-sm" 
                                            : "bg-red-500 border-red-600 text-white shadow-sm";
                                    }
                                    if (idx === currentQIndex) {
                                        bgClass += " ring-2 ring-offset-1 ring-blue-400 border-blue-400 transform scale-105 z-10";
                                    }

                                    return (
                                        <button
                                            key={q.id}
                                            onClick={() => jumpToQuestion(idx)}
                                            className={`w-8 h-8 rounded-md flex items-center justify-center text-xs font-bold border transition-all duration-200 ${bgClass}`}
                                        >
                                            {idx + 1}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                        
                        <div className="p-3 border-t border-gray-100 bg-gray-50 text-xs text-gray-400 text-center">
                            使用键盘 ← → 快速切换
                        </div>
                    </aside>

                    {/* Main Content Area */}
                    <main 
                        ref={mainContentRef}
                        className="flex-1 overflow-y-auto main-scroll relative"
                    >
                        {/* Mobile Header (Progress Bar) */}
                        <div className="md:hidden sticky top-0 z-20 bg-white border-b border-gray-200 px-4 py-3 flex justify-between items-center shadow-sm">
                            <span className="font-bold text-gray-700">第 {currentQIndex + 1} 题</span>
                            <div className="text-xs text-gray-500">
                                <span className="text-green-600 font-bold">{correctCount}</span> / {Object.keys(userAnswers).length}
                            </div>
                        </div>

                        {/* Content Wrapper */}
                        <div className="min-h-full w-full flex flex-col items-center p-4 md:p-8 pb-32">
                             <div className="w-full max-w-3xl my-auto">
                                <AnimatePresence mode='wait'>
                                    <motion.div
                                        key={currentQ.id}
                                        initial={{ opacity: 0, y: 15 }}
                                        animate={{ opacity: 1, y: 0 }}
                                        exit={{ opacity: 0, y: -15 }}
                                        transition={{ duration: 0.25 }}
                                        className="w-full bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 flex-shrink-0"
                                    >
                                        {/* Question Header */}
                                        <div className="bg-gradient-to-r from-blue-600 to-indigo-600 p-6 md:p-8 text-white relative overflow-hidden">
                                            <div className="absolute top-0 right-0 p-4 opacity-10">
                                                <svg className="w-24 h-24" fill="currentColor" viewBox="0 0 20 20"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" /><path fillRule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clipRule="evenodd" /></svg>
                                            </div>
                                            <div className="relative z-10">
                                                <div className="flex items-center gap-3 mb-3">
                                                    <span className="bg-white/20 px-2 py-0.5 rounded text-xs font-semibold backdrop-blur-sm tracking-wide">单选题</span>
                                                    <span className="text-blue-100 text-xs font-medium opacity-80">ID: {currentQ.id}</span>
                                                </div>
                                                <h2 className="text-lg md:text-xl font-bold leading-relaxed whitespace-pre-wrap tracking-wide">
                                                    {currentQ.question}
                                                </h2>
                                            </div>
                                        </div>

                                        {/* Question Body */}
                                        <div className="p-6 md:p-8">
                                            
                                            {/* Dynamic Content: Tables */}
                                            {currentQ.tableData && (
                                                <div className="w-full overflow-x-auto mb-6 rounded-lg border border-gray-100 shadow-sm">
                                                    <table className="os-table min-w-full">
                                                        <tbody>
                                                            {currentQ.tableData.map((row, rIdx) => (
                                                                <tr key={rIdx}>
                                                                    {row.map((cell, cIdx) => (
                                                                        rIdx === 0 ? <th key={cIdx}>{cell}</th> : <td key={cIdx}>{cell}</td>
                                                                    ))}
                                                                </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            )}

                                            {/* Dynamic Content: Code */}
                                            {currentQ.code && (
                                                <div className="mb-6 relative group">
                                                    <div className="absolute top-2 right-2 text-xs text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity">code</div>
                                                    <pre className="code-block text-sm md:text-base">{currentQ.code}</pre>
                                                </div>
                                            )}

                                            {/* Options Grid */}
                                            <div className="space-y-3">
                                                {currentQ.options.map((option, oIdx) => {
                                                    const optionChar = option.charAt(0);
                                                    let stateClass = "border-gray-100 hover:border-blue-400 hover:bg-blue-50/50 text-gray-700";
                                                    let iconClass = "bg-gray-100 text-gray-500 group-hover:bg-blue-500 group-hover:text-white";

                                                    if (currentAns) {
                                                        if (optionChar === currentQ.answer) {
                                                            stateClass = "border-green-500 bg-green-50 text-green-800 ring-1 ring-green-500";
                                                            iconClass = "bg-green-500 text-white";
                                                        } else if (currentAns.selected === optionChar) {
                                                            stateClass = "border-red-400 bg-red-50 text-red-800 ring-1 ring-red-400";
                                                            iconClass = "bg-red-500 text-white";
                                                        } else {
                                                            stateClass = "border-gray-100 text-gray-400 opacity-50";
                                                            iconClass = "bg-gray-100 text-gray-300";
                                                        }
                                                    }

                                                    return (
                                                        <button
                                                            key={oIdx}
                                                            disabled={!!currentAns}
                                                            onClick={() => handleAnswer(optionChar)}
                                                            className={`w-full text-left p-4 rounded-xl border-2 transition-all duration-200 flex items-start group relative overflow-hidden ${stateClass}`}
                                                        >
                                                            <div className={`w-8 h-8 rounded-full flex items-center justify-center mr-4 text-sm font-bold flex-shrink-0 transition-colors mt-0.5 ${iconClass}`}>
                                                                {optionChar}
                                                            </div>
                                                            <span className="font-medium text-sm md:text-base pt-1">{option.substring(2)}</span>
                                                            
                                                            {currentAns && optionChar === currentQ.answer && (
                                                                <div className="absolute right-4 top-1/2 -translate-y-1/2 text-green-600">
                                                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path></svg>
                                                                </div>
                                                            )}
                                                        </button>
                                                    );
                                                })}
                                            </div>

                                            {/* Explanation Area */}
                                            {currentAns && (
                                                <div className="mt-8 pt-6 border-t border-gray-100 animate-fade-in-up">
                                                    <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-4">
                                                        <div className={`text-lg font-bold flex items-center gap-2 ${currentAns.isCorrect ? 'text-green-600' : 'text-red-600'}`}>
                                                            {currentAns.isCorrect ? (
                                                                <>
                                                                    <span className="text-2xl">🎉</span> 回答正确！
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <span className="text-2xl">😢</span> 回答错误，选 {currentQ.answer}
                                                                </>
                                                            )}
                                                        </div>
                                                        <button
                                                            onClick={() => setShowExplanation(!showExplanation)}
                                                            className="px-5 py-2.5 bg-indigo-50 text-indigo-700 rounded-lg hover:bg-indigo-100 active:bg-indigo-200 font-medium text-sm transition-all flex items-center justify-center gap-2"
                                                        >
                                                            {showExplanation ? '收起解析' : '查看解析'}
                                                            <svg className={`w-4 h-4 transform transition-transform ${showExplanation ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                        </button>
                                                    </div>
                                                    
                                                    <AnimatePresence>
                                                        {showExplanation && (
                                                            <motion.div
                                                                initial={{ opacity: 0, height: 0 }}
                                                                animate={{ opacity: 1, height: 'auto' }}
                                                                exit={{ opacity: 0, height: 0 }}
                                                                className="overflow-hidden"
                                                            >
                                                                <div className="bg-slate-50 rounded-xl p-5 border border-slate-200 text-slate-700 text-sm md:text-base leading-relaxed">
                                                                    <div className="font-bold text-slate-900 mb-2 flex items-center gap-2">
                                                                        <svg className="w-5 h-5 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                                                        解析详情
                                                                    </div>
                                                                    {currentQ.explanation}
                                                                </div>
                                                            </motion.div>
                                                        )}
                                                    </AnimatePresence>
                                                </div>
                                            )}
                                        </div>

                                        {/* Action Bar (Footer inside card) */}
                                        <div className="bg-gray-50/80 p-5 border-t border-gray-200 flex justify-between items-center backdrop-blur-sm">
                                            <button
                                                onClick={prevQuestion}
                                                disabled={currentQIndex === 0}
                                                className={`px-4 py-2 rounded-lg font-medium transition-colors flex items-center gap-1 ${currentQIndex === 0 ? 'text-gray-300 cursor-not-allowed' : 'text-gray-600 hover:bg-gray-200 hover:text-gray-900'}`}
                                            >
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path></svg>
                                                上一题
                                            </button>
                                            <button
                                                onClick={nextQuestion}
                                                disabled={currentQIndex === questionsData.length - 1}
                                                className={`px-6 py-2.5 rounded-lg font-bold shadow-md transition-all flex items-center gap-2 transform active:scale-95 ${
                                                    currentQIndex === questionsData.length - 1 
                                                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed shadow-none' 
                                                    : 'bg-indigo-600 text-white hover:bg-indigo-700 hover:shadow-lg'
                                                }`}
                                            >
                                                下一题
                                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7"></path></svg>
                                            </button>
                                        </div>
                                    </motion.div>
                                </AnimatePresence>
                            </div>
                        </div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
